//Assignment 3
//EE480 Spring 2017
//Griffin Urton, Baiyoke Nateesuwan, Jong Yeu Wu

// standard sizes
`define ARRAY		[1:0]
`define STATE		[4:0]
`define OP		[4:0]
`define WORD		[15:0]
`define HALFWORD	[7:0]
`define REGSIZE		[511:0]   
`define MEMSIZE		[65535:0]
`define Opcode		[15:12]
`define Immed		[11:0]
`define PREFIX		[3:0]

// initial states
`define Start	5'b11111
`define GetOp   5'b11110

// opcode values/ state numbers
`define NOimmed 4'b0000
`define OPget 4'b0001
`define OPpop 4'b0010
`define OPput 4'b0011
`define OPcall 4'b 0100
`define OPjumpf 4'b0101
`define OPjump 4'b0110
`define OPjumpt 4'b0111
`define OPpre 4'b1000
`define OPpush 4'b1001

// secondary opcode field values
`define OPadd 12'h0001
`define OPand 12'h0002
`define OPdup 12'h0003
`define OPload 12'h0004
`define OPlt 12'h0005
`define OPor 12'h0006
`define OPret 12'h0007
`define OPstore 12'h0008
`define OPsub 12'h0009
`define OPsys 12'h000A
`define OPtest 12'h000B
`define OPxor 12'h000C



module decode(sp, dest, src, prefix, preEmpty, preFlag, ir);
output reg `HALFWORD sp;
output reg `WORD dest, src;
output reg `PREFIX prefix;
output reg preEmpty;
input preFlag;
input `WORD ir;

always @(ir) begin
  case (ir `Opcode)
  		`NOimmed: begin
		case(ir `Immed)
	  		`OPadd: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end
		
			`OPand: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end
			
			`OPdup: begin
					dest = sp + 1;
					src = sp;
					sp = sp + 1;
			end
		
			`OPload: begin
					dest = sp;
			end
		
			`OPlt: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end
		
			`OPor: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end
		
			`OPret: begin
					src = sp;
					sp = sp - 1;
			end
		
			`OPstore: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end
		
			`OPsub: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end
		
		
			`OPtest: begin
					src = sp;
					sp = sp - 1;
			end
		
			`OPxor: begin
					dest = sp - 1;
					src = sp;
					sp = sp - 1;
			end	
		endcase
	end
	
    `OPget: begin 
    		dest = sp + 1;
		src = sp - ir `Immed;
		sp = sp + 1;
	end

    `OPpop: begin 
    		sp = sp - ir `Immed;
	end

    `OPput: begin 
    		dest = sp - ir `Immed;
		src = sp;
	end


    `OPcall: begin
		dest = sp + 1;
		sp = sp + 1;
	end
   

    `OPpre: begin
		prefix = (ir[11:8] >> 8);
		preEmpty = 0;
	end

    OPpush: begin
   		 dest = sp + 1;
		 sp = sp + 1;
   	 end
endcase


preEmpty = (preFlag ? 1 : 0);
end
endmodule

//ALU
module alu(result, op, in1, in2);
output reg `WORD result;
input wire `Immed op;
input wire `WORD in1; 
input wire `WORD in2;

always @(op, in1, in2) begin
  case (op) // in1 = dest_value, in2 = src_value
    `OPadd: begin result = in1 + in2; end
    `OPand: begin result = in1 & in2; end
    `OPdup: begin result = in2; end
    `OPload: begin result = mainmem[in1]; end
    `OPlt: begin result = (in1 < in2); end
    `OPor: begin result = in1 | in2; end
    `OPsub: begin result = in1 - in2; end
    `OPxor: begin result = in1 ^ in2; end
    default: begin result = in1; end
  endcase
end
endmodule

module processor(halted, reset, clk); // operator input removed
output halted;
input clk;
input reset;	
reg `WORD regfile `REGSIZE;
reg `WORD mainmem `MEMSIZE;

    

reg `HALFWORD sp `ARRAY;
reg `WORD pc `ARRAY;
reg `WORD dest `ARRAY; 
reg `WORD src `ARRAY;
reg `WORD dest_value `ARRAY;
reg `WORD src_value `ARRAY;
reg `WORD result_value `ARRAY;
reg `PREFIX prefix `ARRAY;
reg `WORD ir `ARRAY;   	// Register that holds instruction spec code
reg torf `ARRAY;       	// True or false register
reg preEmpty `ARRAY;	// Register describing the state of pre (loaded = 0, not loaded = 1)
reg preFlag `ARRAY; 	// Flag used to alert preEmpty owner that pre needs to be written
reg writeFlag `ARRAY;	// Flag to determine whether to write to the stack or not
reg thread;
reg halt `ARRAY;


always @ (reset) begin
	pc[thread] = 0;
	pc[!thread] = 0;
	halt[thread] = 0;
	halt[!thread] = 0;
	sp[thread] = 0;
	sp[!thread] = 0;
//	torf[thread] = 0;
//	torf[!thread] = 0;
	preEmpty[thread] = 1;
	preEmpty[!thread] = 1;
	writeFlag[thread] = 1;
	writeFlag[!thread] = 1;
	$readmemh1(mainmem);
end

always@(*) begin halted = halt[1] & halt[0]; end

// Toggle thread each clock cycle
always@(posedge clk) thread = !thread;

decode mydecode(sp[thread], dest[thread], src[thread], prefix[thread], preEmpty[thread], preFlag[thread], ir[thread]);

always @(thread) ir[thread] = mainmem[pc[thread]];

always @(*) begin
	dest_value[thread] = regfile[thread ? dest[thread] + 256: dest[thread]];
	src_value[thread] = regfile[thread ? src[thread] + 256 : src[thread]];
	

case (ir[thread] `Opcode)
   	 
	`NOimmed: begin
   	case (ir[thread] `Immed)
		 
   		`OPret: begin pc[thread] = src_value[thread]; writeFlag[thread] = 0; end

   		`OPstore: begin mainmem[dest_value[thread]] = src_value[thread]; writeFlag[thread] = 0; end

   		`OPsys: begin halt[thread] = 1; writeFlag[thread] = 0; end
			
		`OPtest: begin torf = (src_value[thread] ? 1 : 0); writeFlag[thread] = 0; end
		
		default: alu stackALU(result_value[thread], ir[thread] `Immed, dest_value[thread], src_value[thread]);
			

   	endcase
	dest_value[thread] <= result_value[thread];
    	end
   	 
    //With `Immed

	//GET:  d=sp+1; s=sp-unsigned(immed12); ++sp; reg[d]=reg[s]
	`OPget: begin 
    		if(!halt[thread]) begin
    			dest_value[thread] = src_value[thread];
		end
	end

	//PUT: d=sp-unsigned(immed12); s=sp; reg[d]=reg[s]
	`OPput: begin 
		if(!halt[thread]) begin
		dest_value = src_value;
		end
	end

	//CALL:  d=sp+1; ++sp; reg[d]=pc+1; pc=prefix({(pc>>12), immed12})
	`OPcall: begin
		if(!halt[thread]) begin
			dest_value[thread] = pc[thread] + 1;
			if(!preEmpty[thread]) begin
		   		pc[thread] = {prefix[thread], ir[thread] `Immed};
		   		preFlag[thread] = 1;
   	 		end
    			else begin pc[thread] = ir[thread] `Immed; end
	end

	//JUMPF: if (!torf) pc=prefix({(pc>>12), immed12});
	`OPjumpf: begin
		if(!halt[thread]) begin
			writeFlag[thread] = 0;
    			if(!torf[thread]) begin
   	 			if(!preEmpty) begin
   					pc[thread] = {prefix[thread], ir[thread] `Immed};
   					preFlag[thread] = 1;
    				end
    				else begin
        				pc = ir `Immed;
    				end
    			end
    		end
	end


	//JUMP: pc=prefix({(pc>>12), immed12})
	`OPjump: begin
		if(!halt[thread]) begin
			writeFlag[thread] = 0;
			if(!preEmpty[thread]) begin
   				pc = {prefix[thread], ir[thread] `Immed};
   				preFlag[thread] = 1;
			end
			else begin
    			pc[thread] = ir[thread] `Immed;
			end
		end
	end


	//JUMPT: if (torf) pc=prefix({(pc>>12), immed12})
	`OPjumpt: begin
		if(!halt[thread]) begin
			writeFlag[thread] = 0;
			if(torf[thread]) begin
				if(!preEmpty[thread]) begin
				pc = {prefix[thread], ir[thread] `Immed};
				preFlag[thread] = 1;
        			end
			end
    			else begin
        			pc[thread] = ir[thread] `Immed;
        		end
		end
	end

	//PUSH: d=sp+1; ++sp; reg[d]=prefix(sign_extend(immed12));
	`OPpush: begin
		if(!halt[thread]) begin
			prefix = (ir[thread][11] ? 4b'1111 : 4'b0000);
			dest_value[thread] = {prefix, ir[thread] `Immed}
		end
   	 end
	 
	 default: begin writeFlag = 0; end;
endcase
end
always @(*)
if(!halt[thread] && writeFlag) regfile[thread ? dest[thread] + 256 : dest[thread]] = dest_value;
endmodule // processor

     
module testbench;
	reg reset = 0;
	reg clk = 0;
	wire halted `ARRAY;
	processor PE(halted, reset, clk);
	initial begin
  	$dumpfile;
  	$dumpvars(0, PE);
  	#10 reset = 1;
  	#10 reset = 0;
  	while (!halted) begin
    	#10 clk = 1;
   	#10 clk = 0;
 	end
  	$finish;
	end
endmodule
